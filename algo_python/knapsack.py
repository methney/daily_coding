# 쪼갤수없는 Fractional Knapsack Problem
# 쪼갤수있는 문제는 탐욕그리디 알고리즘, 이거는 그냥 하위순환(Recursive)로 대응이라고 하는데..타뷸레이션이래..(6X16) = (가방+1) X (냅색허용량+1)
# 여기서는 뭐..recursive한거는 없는것 같은데?
# 허용한 용량에 넣을수 있는 최대금액을 리턴
# knapsack_basic.py문제를 먼저 풀어볼것..

def solution(cargo):
    capacity = 5 #kg
    pack = []

    # 6 X 16의 경우의수...
    for i in range(len(cargo)+1): #+1은 짐이 없는 경우의 수(근데 왜 하필 loop문으로?) 
        pack.append([])
        for c in range(capacity + 1): # 무게를 kg단위로 나눠서 처리? 
            if i==0 or c==0:
                pack[i].append(0) # 여기서 넣는 0이 가격이야 무게야? (가능한 최대무게? 아니야 $가치야..돈돈!)
            elif cargo[i-1][1] <= c: # 일단 가방에 넣을수 있는 가능한 무게안에서...
                print(i,'/',c, cargo[i-1], ' pack[', i, '] = ','max(', pack[i-1][c],',', cargo[i-1][0], '+', pack[i-1][c-cargo[i-1][1]],')')

                # 여기가 핵심인데, 이 하위순회문제의 핵심인거지...
                # 보면, 일단 max(가방안동일한 무게 상자의 최대가치, 이번차수(상자)만큼의가치 + A) 누적가치계산을 해야한다.
                # A : 이번허용가능한무게(c) - 이번차수상자의 무게를 뺀 남은 무게를 혹시 가방안 상자중에 맞아떨어지는게 있다면 그것의 가치(같은무게의최대가치)
                # 가방안 무게상자의 최대가치라고 할수있는 것은 바로아래.. max값으로 넣기때문
                pack[i].append( 
                    max( 
                        pack[i-1][c],
                        cargo[i-1][0] + pack[i-1][c-cargo[i-1][1]]
                    )
                )
                # 경우의 수(참고, 차라리 그냥 돌려봐라...)
                # i = 1, c = 1
                # cargo[0][1] (4,12)에서 12 <= 1 안되니깐...하위에 가서 pack[1]에 pack[0][1] 값을 넣는다. 
                # 근데 pack[0][1]값이 뭔데? 찍어보면 그냥 0으로 나오기는 하는데..
                # 이거 첫 if i==0 or c==0에서.. i=0 배열에 c값이뭐가 나오든 이미 다 채웠다(5kg 0~5) . 0으로..
                # ----------------------------------------------------------------------------------------
                # i = 1, c = 2
                # cargo[0][1] (4,12)에서 12 <= 2 안되니깐...하위에 가서 pack[1]에 pack[0][2] 값을 넣는다.
                # 그렇게 쭉~ i=1, c=11까지 가방에 0을 담고..
                # ----------------------------------------------------------------------------------------
                # i = 2, c = 1
                # cargo[1][1] (2,1)에서 1 <= 1 되니깐.. 최대값을 넣기위해 진입
                # cargo[1][0] 은 $2, pack[1][c-1]해서 pack[1][1-1] 이니깐 위에 i=1일때 쭉 넣었던것중에 pack[1][0]은 위에서 0으로 넣어줬었고..
                # 결국 max(cargo[i-1][0] + pack[i-1][c-cargo[i-1][1]], pack[i-1][c]) 이 값은 max($2 + 0, pack[1][1]=0) >> 결국 2가 되겠네..근데 이건 금액아니야? (맞다!)
                # 근데,여기서 c-cargo[i-1][1] 이게 뭘 의미하는거냐? 하위순회중인 capacity(c:1) - 현재상자의무게(1kg) = 남은용량(0kg)이네.. pack[1][남은용량] 이건가? 이경우엔 pack[1][0] (capacity 총5kg중에 1kg순회중)
                # pack[1][0] 는 0($) 인데..뭘의미하는거지? 결국 cargo[i-1][0] + pack[i-1][c-cargo[i-1][1]] 는 $2 + $0 이고.. max($2 + $0, $0) >> 2네..
                # ----------------------------------------------------------------------------------------
                # i = 2, c = 2
                # cargo[1][1] (2,1)에서 1 <= 1되니깐.. 최대값 계산 진입
                # cargo[1][0] 은 $2, pack[1][c-1]해서 pack[1][2-1] 이니깐.. pack[1][1] >> $0
                # max($2 + 0, pack[1][2]) ...


            else: # 가방에 넣을수 없는 경우의 무게(근데 이걸 왜 가방에 담는거지?) 
                print(i,'/',c,'-----', pack[i-1][c], pack)
                pack[i].append(pack[i-1][c])
        print('-----------')
    return pack[-1][-1]
    # 제일마지막행마지막값을 리턴...

# ($4 12kg)...
cargo = [
    (4,12),
    (2,1),
    (10,4),
    (1,1),
    (2,2)
]

print(solution(cargo))
# 이거 결과가 그냥 15인데? 뭐야? 